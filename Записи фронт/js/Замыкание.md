# Теория о замыканиях

Замыкание (closure) в JavaScript — это функция, которая "замыкает" на себе переменные из своего внешнего лексического окружения. Это означает, что функция может запоминать и получать доступ к переменным из [[Области видимости и поднятие (hoisting)|области видимости]], в которой она была создана, даже после завершения выполнения этой области видимости.

Это возможно благодаря лексической области видимости, которая определяет, где и как можно получить доступ к переменным. Когда функция создаётся, JavaScript сохраняет ссылку на область видимости, в которой она была объявлена.

Простыми словами: замыкание позволяет функции "запомнить", где она была объявлена, и использовать переменные из этой области, даже если она вызывается за её пределами.

---

# Пример замыкания

``` js
function outerFunction() {
    let outerVariable = 'Я из внешней функции';

    function innerFunction() {
        console.log(outerVariable);
    }

    return innerFunction;
}

const closure = outerFunction(); // outerFunction завершает выполнение
closure(); // => 'Я из внешней функции'
```


Объяснение:  
1. При вызове outerFunction создаётся своя область видимости.
2. innerFunction имеет доступ к outerVariable, поскольку была создана в этой области.
3. outerFunction завершилась, но innerFunction (замыкание) всё ещё сохраняет доступ к переменной outerVariable.

По факту это используется постоянно в React. Мы объявляем обработчик, закидываем его в дочерний компонент. В обработчике работаем с окружение функции(допустим setIsOpen(true)). В месте вызова функции нет доступа к setIsOpen, но функция может с ним работать т.к. "запомнила" своё лексическое окружение. 

==Это крайне очевидная вещь ==

---

# Варианты практического применения

## 1. Создание приватных данных или методов
   Замыкания позволяют скрыть данные и сделать их недоступными извне.

   
``` js
function createCounter() {
   let count = 0; // приватная переменная

   return {
	   increment() {
		   count++;
		   console.log(count);
	   },
	   decrement() {
		   count--;
		   console.log(count);
	   },
	   getCount() {
		   return count;
	   }
   };
}

const counter = createCounter();
counter.increment(); // 1
counter.increment(); // 2
console.log(counter.getCount()); // 2
```


## 2. Функции-генераторы или каррирование
   Замыкания позволяют создавать удобные функции для повторного использования. 

   
  ``` js
function multiply(factor) {
   return function (value) {
	   return value * factor;
   };
}

const double = multiply(2);
const triple = multiply(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```
   ==Каррирование часто используем на формах, где есть массивы. Там передаются индексы или id ==
   ### Почему это удобно
   Помимо использования в обработчиках, удобно создавать похожие функции. ==Но можно обойтись пропсами к функции==

1. Повторное использование: Мы можем создавать множество новых функций (например, double, triple, quadruple и т.д.), не дублируя код.
2. Лаконичность: Код выглядит чище и легче читается, благодаря использованию замыкания.

## 3. Асинхронные операции
   Замыкания помогают "запомнить" контекст в асинхронных операциях.

   
  ``` js
function fetchWithDelay(url, delay) {
   setTimeout(() => {
	   console.log(`Fetching data from ${url}`);
   }, delay);
}

fetchWithDelay('https://api.example.com', 2000);
```


## 4. Обработка событий
   Замыкания используются для создания обработчиков событий с сохранением состояния.

   
   ``` js
function handleClick(buttonId) {
   return function () {
	   console.log(`Button ${buttonId} clicked!`);
   };
}

const button1 = document.getElementById('button1');
const button2 = document.getElementById('button2');

button1.addEventListener('click', handleClick(1));
button2.addEventListener('click', handleClick(2));
```
   ==Такое постоянно используется==

---

# Особенности и потенциальные проблемы
## Потребление памяти  
   Замыкания могут увеличивать использование памяти, так как функции сохраняют ссылки на переменные из внешней области видимости. Это важно учитывать для долгоживущих объектов.
## Проблемы с циклами  
   При использовании замыканий в циклах нужно быть осторожным:
### Пример с использованием var

``` js
for (var i = 0; i < 5; i++) {
   setTimeout(function () {
     console.log(i); // Всегда 5
   }, 1000);
}

```
#### Почему так происходит

В этом примере используется var для объявления переменной i. Переменные, объявленные с помощью var, имеют функциональную область видимости. Это означает, что когда цикл завершится, переменная i будет иметь значение 5, как результат последней итерации цикла (i < 5 больше не выполняется, следовательно i становится 5). 

Когда setTimeout выполняет свои коллбэки через 1000 миллисекунд, i уже равно 5, потому что цикл уже завершился. Таким образом, каждая функция в setTimeout ссылается на одно и то же значение i, которое равно 5.
#### Как это исправить

Есть несколько способов добиться правильного поведения. Основной подход - использование блоковой области видимости с let, но можно также использовать замыкания.

#### 1. Использование let

Переменная let имеет блочную область видимости, что означает, что для каждой итерации цикла i будет иметь своё собственное значение.

``` js
for (let i = 0; i < 5; i++) {
   setTimeout(function () {
     console.log(i); // Корректно выводит 0, 1, 2, 3, 4
   }, 1000);
}

```

#### 2. Замыкания

Другой способ - создать новую область видимости внутри цикла с помощью функции (замыкания).

``` js
for (var i = 0; i < 5; i++) {
   (function(i) {
     setTimeout(function () {
       console.log(i); // Корректно выводит 0, 1, 2, 3, 4
     }, 1000);
   })(i);
}
```


#### 3. Использование const внутри цикла for

Еще один способ - использовать const для объявления переменной внутри тела цикла.

``` js
for (var i = 0; i < 5; i++) {
   const j = i;
   setTimeout(function () {
     console.log(j); // Корректно выводит 0, 1, 2, 3, 4
   }, 1000);
}
```
#### Заключение

Исправление проблемы с использованием правильной области видимости для переменной i внутри цикла помогает убедиться, что каждая функция setTimeout получает своё собственное значение i на каждой итерации. Наиболее рекомендованные способы — использовать либо let вместо var, либо создавать новую область видимости с помощью замыканий.
## Проблема использования setState в одном обработчике

Когда в React внутри обработчика событий вызывается setState, обновление состояния происходит асинхронно. Это означает, что значение состояния (state) не обновляется сразу. Если в одном обработчике несколько раз вызывается setState, полагаться на текущее значение состояния может быть рискованно, поскольку каждое обновление вызовет ререндер компонента лишь через определенное время.

### Пример неправильного использования

``` jsx
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    // Пытаемся увеличить значение состояния дважды
    setCount(count + 1);
    setCount(count + 1);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Increment</button>
    </div>
  );
}

export default Counter;
```


### Почему этот код может не работать как ожидалось: 

Вместо увеличения значения на 2, после клика только один раз значение будет увеличено на 1. Это происходит потому, что оба вызова setCount используют старое значение count.

### Решение использовать функцию обратного вызова (callback) в setState

Чтобы избежать этой проблемы, можно использовать функциональный вариант setState, который принимает текущий state как аргумент.

### Исправленный пример

``` jsx
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    // Используем функциональную форму `setState`
    setCount(prevCount => prevCount + 1);
    setCount(prevCount => prevCount + 1);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Increment</button>
    </div>
  );
}

export default Counter;
```


### Почему это работает

Функциональный вариант setState гарантирует, что вы всегда будете работать с актуальным состоянием. Функция обратного вызова получает предыдущее значение состояния, что позволяет корректно обновлять состояние даже при нескольких вызовах setState.

### Заключение

Использование функции обратного вызова в setState - это безопасный и корректный способ изменять состояние многократно в рамках одного обработчика. Это уменьшает вероятность ошибок и обеспечивает ожидаемое поведение компонентов при их повторной перерисовке.

---
# Заключение

Замыкания — это мощный инструмент JavaScript, который лежит в основе многих ключевых концепций языка. Они позволяют создавать гибкие и эффективные программы, однако с ними нужно быть осторожным, чтобы избежать проблем с памятью или неожиданного поведения.

Попробуй самостоятельно реализовать несколько примеров из практики, чтобы лучше понять, как работают замыкания! 🚀