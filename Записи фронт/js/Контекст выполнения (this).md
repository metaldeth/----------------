В JavaScript контекст выполнения (или контекст вызова) определяет, как функция была вызвана и к какому объекту она имеет доступ через ключевое слово this.

# Основные аспекты контекста выполнения (this)

## 1. Глобальный контекст  
В глобальном контексте (например, при запуске скрипта непосредственно браузером) this ссылается на глобальный объект, который в браузерах называется window.
``` js
console.log(this); // В браузере выведет объект window
```

## 2. Контекст функции

- Обычная функция: В случае вызова обычной функции без конкретного объекта, this также будет ссылаться на глобальный объект (в строгом режиме - undefined).
``` js
function showThis() {
	console.log(this);
}
showThis(); // window в некстрогом режиме, undefined в строгом режиме
```

- Функция как метод объекта: Если функция вызывается как метод объекта, this будет ссылаться на этот объект.
``` js
const obj = {
	name: "Object",
	showThis: function() {
		console.log(this);
	}
};

obj.showThis(); // {name: "Object", showThis: f}
```
    

## 3. Контекст стрелочной функции
   Стрелочные функции не имеют своего контекста выполнения this. Вместо этого они захватывают this из окружающего контекста (лексического окружения).

``` js
const obj = {
	name: "Object",
	showThis: function() {
		const arrowShowThis = () => console.log(this);
		arrowShowThis();
	}
};
obj.showThis(); // {name: "Object", showThis: f}
```

## 4. Контекст конструкторов
При вызове функции-конструктора с помощью ключевого слова new, this будет ссылаться на новый созданный объект.

``` js
function Person(name) {
	this.name = name;
}

const person = new Person('John');
console.log(person.name); // John
``` 

## 5. [[Методы call, apply и bind]]
Эти методы позволяют явно задавать значение this для функции.

``` js
 function showThis() {
	console.log(this.name);
}

const obj = { name: "Tom" };

showThis.call(obj); // "Tom"
showThis.apply(obj); // "Tom"

const boundShowThis = showThis.bind(obj);
boundShowThis(); // "Tom"
```

# Примеры задач и их решение

## Задача 1:
Напишите функцию, которая возвращает значение this. Вызовите ее тремя разными способами и объясните результат.

Решение:
``` js
function example() {
    return this;
}

console.log(example()); // В глобальном контексте: window (если не строгий режим)
console.log(example.call({name: 'obj'})); // Явно заданный контекст: {name: 'obj'}
console.log(new example()); // В режиме конструктора: новый объект example {}
```


## Задача 2:
Используя bind, создайте функцию, которая всегда использует заданный контекст.

Решение:
``` js
const obj = { name: 'Object' };

function greet() {
    console.log(`Hello, ${this.name}`);
}

const boundGreet = greet.bind(obj);
boundGreet(); // "Hello, Object"
```


### Области применения различных подходов

- Глобальный контекст: Удобен при создании полифилов и глобальных утилит, однако его желательно избегать для улучшения читаемости и тестирования кода.
- Методы объектов: Обширно используется при разработке библиотек, фреймворков и компонентных систем.
- Стрелочные функции: Преимущество для вложенных функций, callback-ов, class-based компонент в React.
- Конструкторы: Используются для создания экземпляров объектов, инстанциации классов.
- call, apply, bind: Полезны для выполнения функции в контексте другого объекта, создания частично примененных функций.