**Определение:**  
Event Loop — это механизм, который управляет выполнением асинхронных операций в браузере, используя **неблокирующую модель ввода-вывода**.

## Основные моменты:

- JavaScript в браузере выполняется в **одном потоке**, что делает Event Loop критически важным для обработки асинхронных задач.
    
- Event Loop позволяет выполнять такие операции, как:
    
    - **Сетевые запросы** (например, Fetch API, XMLHttpRequest).
    - **Обработчики событий** (клики, скроллы, ввод данных и т.д.).
    - **Таймеры** (`setTimeout`, `setInterval`).

## Особенности архитектуры:

- Event Loop **не является частью движка JavaScript** (например, V8).
- Он предоставляется **средой выполнения** (в данном случае — браузером) и может отличаться в зависимости от среды (например, в Node.js он устроен иначе).
- В браузере Event Loop взаимодействует с движком через **Web API**, который предоставляет доступ к асинхронным функциям (например, `fetch`, `setTimeout`, DOM-события).

# Составные части Event Loop

## Call Stack (Стек вызовов)

Call Stack — это стек вызовов, за который отвечает движок JavaScript.

### Принцип работы:

1. Если что-то поступает в Call Stack, оно кладется **наверх**.
2. Если что-то забирается из Call Stack, оно забирается **сверху**.

---

### Пример 1: Простые функции

```js
function sum(a, b) {
  return a + b;
}

const first = sum(5, 5);
const second = sum(1, 2);
const third = sum(3, 4);
```

**Объяснение:**  
В этом случае код будет попадать в Call Stack и сразу выполняться. В Call Stack будет находиться только **одна функция** в каждый момент времени.

---

### Пример 2: Вложенные функции

```js
function first() {
  // ...
}

function second() {
  first();
}

function third() {
  second();
}

third();
```

**Объяснение:**  
Здесь логика работы Call Stack меняется:

1. Сначала выполняется `third()`, которая вызывает `second()`. При этом `third()` остается в Call Stack, ожидая выполнения вложенной функции.
2. Функция `second()` вызывает `first()`, и по аналогии `second()` остается в Call Stack.
3. Далее выполняется `first()`, затем `second()`, и в конце — `third()`.

**Этапы работы Call Stack:**

```js
// 1 этап
third()

// 2 этап
second()
third()

// 3 этап
first()
second()
third()

// 4 этап
second()
third()

// 5 этап
third()
```

**Итог:**  
Функции сначала попадают в стек **снизу вверх**, а затем начинают выполняться **сверху вниз**.

### Пример 3: Рекурсия

```js
function factorial(n) {
	if(n < 2) {
		return 1;
	}
	return n * factorial(n - 1);
}

factorial(5);
```

**Этапы:**

```js
// 1 этап
factorial(5)

// 2 этап
factorial(4)
factorial(5)

// 3 этап
factorial(3)
factorial(4)
factorial(5)

// 4 этап
factorial(2)
factorial(3)
factorial(4)
factorial(5)

// 5 этап
factorial(1)
factorial(2)
factorial(3)
factorial(4)
factorial(5)

// 6 этап
factorial(2)
factorial(3)
factorial(4)
factorial(5)

// 7 этап
factorial(3)
factorial(4)
factorial(5)

// 8 этап
factorial(4)
factorial(5)

// 9 этап 
factorial(5)
```

### Возможные проблемы

В теории можно переполнить стек и получить ошибку. Необходимо быть осторожным с рекурсией. При опасности переполнения стека лучше решать задачу другим способом, например, с помощью цикла.

## Асинхронные операции

### Работа `setTimeout`

1. Попадает в Call Stack.
2. Передается в Web API.
3. Ждет истечения времени.
4. Попадает в очередь задач.
5. Перемещается в Call Stack для выполнения.

### Работа `addEventListener`

1. Попадает в Call Stack.
2. Web API регистрирует слушатель события (ждет нажатия).
3. После нажатия попадает в очередь задач.
4. Перемещается в Call Stack для выполнения.

Слушатели событий удаляются только явно из кода.

### Работа `Promise`

1. Создается новый промис.
2. Если промис выполнен, колбэк добавляется в очередь микротасков.
3. При следующем цикле Event Loop колбэк выполняется.

## Пример работы с асинхронными операциями

```js
console.log('1');

setTimeout(() => {
	console.log('2');
}, 0);

Promise.resolve().then(() => {
	console.log('3');
});

console.log('4');
```

**Результат:** `1`, `4`, `3`, `2`

**Объяснение:**

1. Сначала выполняются все синхронные операции.
2. Затем выполняются микротаски (промисы).
3. После этого выполняются макротаски (таймеры).

## Очереди

Все асинхронные операции попадают в Web API, где ждут своего времени (срабатывания обработчика, возвращения запроса, истечения таймера и т.д.), после чего попадают в одну из двух очередей: **очередь событий (макротаски)** и **очередь задач (микротаски)**. Всегда сначала выполняются все микротаски, а затем — одна макротаска.

### Макротаски (очередь событий)

1. Таймеры.
2. События (клик, загрузка изображений и т.д.).
3. Браузерные события (рендер и т.д.).

### Микротаски (очередь задач)

1. Промисы.
2. Явное создание микротасков.
3. MutationObserver (наблюдение за изменениями в DOM).

### Пример работы с очередями

```js
console.log('1');

setTimeout(() => {
	console.log('setTimeout 1');
	Promise.resolve().then(() => {
		console.log('promise setTimeout');
	})
}, 0)

setTimeout(() => {
	console.log('setTimeout 2');
}, 0)

Promise.resolve().then(() => {
	console.log('promise 1');
})

Promise.resolve().then(() => {
	console.log('promise 2')
})

console.log('4');
```

**Результат:** `1`, `4`, `promise 1`, `promise 2`, `setTimeout 1`, `promise setTimeout`, `setTimeout 2`.

Этот пример демонстрирует порядок выполнения операций в зависимости от их типа (макротаски и микротаски).

### Пример 1: Сравнение макротасков и микротасков

```javascript
console.log('Start');

setTimeout(() => {
    console.log('Timeout 1');
}, 0);

Promise.resolve().then(() => {
    console.log('Promise 1');
});

setTimeout(() => {
    console.log('Timeout 2');
}, 0);

Promise.resolve().then(() => {
    console.log('Promise 2');
});

console.log('End');
```

**Результат выполнения:**

```
Start
End
Promise 1
Promise 2
Timeout 1
Timeout 2
```

**Объяснение:**

1. Сначала выполняются все синхронные операции: `console.log('Start')` и `console.log('End')`.
2. Затем выполняются все микротаски (промисы): `Promise 1` и `Promise 2`.
3. Наконец, выполняются макротаски (таймеры): `Timeout 1` и `Timeout 2`.

### Пример 2: Вложенные промисы и таймеры

```javascript
console.log('1');

setTimeout(() => {
    console.log('2');

    Promise.resolve().then(() => {
        console.log('3');
    });

}, 0);

Promise.resolve().then(() => {
    console.log('4');
});

console.log('5');
```

**Результат выполнения:**

```
1
5
4
2
3
```

**Объяснение:**

4. Сначала выполняются синхронные операции: `console.log('1')` и `console.log('5')`.
5. Затем выполняются микротаски: `console.log('4')`.
6. После этого выполняется макротаск: `console.log('2')`.
7. Наконец, выполняется микротаск, созданный внутри таймера: `console.log('3')`.

### Пример 3: Микротаски перед макротасками

```javascript
console.log('A');

setTimeout(() => {
    console.log('B');
}, 0);

Promise.resolve().then(() => {
    console.log('C');
});

setTimeout(() => {
    console.log('D');
}, 0);

Promise.resolve().then(() => {
    console.log('E');
});
```

**Результат выполнения:**

```
A
C
E
B
D
```

**Объяснение:**

8. Сначала выполняется синхронная операция: `console.log('A')`.
9. Затем выполняются все микротаски: `console.log('C')` и `console.log('E')`.
10. Наконец, выполняются макротаски: `console.log('B')` и `console.log('D')`.

### Пример 4: Асинхронные операции в цикле

```javascript
console.log('Start');

for (let i = 0; i < 3; i++) {
    setTimeout(() => {
        console.log(i);
    }, 0);
}

Promise.resolve().then(() => {
    console.log('Promise');
});

console.log('End');
```

**Результат выполнения:**

```
Start
End
Promise
0
1
2
```

**Объяснение:**

11. Сначала выполняются синхронные операции: `console.log('Start')` и `console.log('End')`.
12. Затем выполняется микротаск: `console.log('Promise')`.
13. Наконец, выполняются макротаски из цикла: `console.log(0)`, `console.log(1)`, `console.log(2)`.

Эти примеры демонстрируют, как Event Loop управляет порядком выполнения асинхронных операций и как различаются макротаски и микротаски в JavaScript.